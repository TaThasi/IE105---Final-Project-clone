{"ast":null,"code":"const SHA256 = require('crypto-js/sha256');\n\nconst EC = require('elliptic').ec;\n\nconst ec = new EC('secp256k1');\n\nclass Transaction {\n  /**\n   * @param {string} fromAddress\n   * @param {string} toAddress\n   * @param {number} amount\n   */\n  constructor(fromAddress, toAddress, amount) {\n    this.fromAddress = fromAddress;\n    this.toAddress = toAddress;\n    this.amount = amount;\n    this.timestamp = Date.now();\n  }\n  /**\n   * Creates a SHA256 hash of the transaction\n   *\n   * @returns {string}\n   */\n\n\n  calculateHash() {\n    return SHA256(this.fromAddress + this.toAddress + this.amount + this.timestamp).toString();\n  }\n  /**\n   * Signs a transaction with the given signingKey (which is an Elliptic keypair\n   * object that contains a private key). The signature is then stored inside the\n   * transaction object and later stored on the blockchain.\n   *\n   * @param {string} signingKey\n   */\n\n\n  signTransaction(signingKey) {\n    // You can only send a transaction from the wallet that is linked to your\n    // key. So here we check if the fromAddress matches your publicKey\n    if (signingKey.getPublic('hex') !== this.fromAddress) {\n      throw new Error('You cannot sign transactions for other wallets!');\n    } // Calculate the hash of this transaction, sign it with the key\n    // and store it inside the transaction obect\n\n\n    const hashTx = this.calculateHash();\n    const sig = signingKey.sign(hashTx, 'base64');\n    this.signature = sig.toDER('hex');\n  }\n  /**\n   * Checks if the signature is valid (transaction has not been tampered with).\n   * It uses the fromAddress as the public key.\n   *\n   * @returns {boolean}\n   */\n\n\n  isValid() {\n    // If the transaction doesn't have a from address we assume it's a\n    // mining reward and that it's valid. You could verify this in a\n    // different way (special field for instance)\n    if (this.fromAddress === null) return true;\n\n    if (!this.signature || this.signature.length === 0) {\n      throw new Error('No signature in this transaction');\n    }\n\n    const publicKey = ec.keyFromPublic(this.fromAddress, 'hex');\n    return publicKey.verify(this.calculateHash(), this.signature);\n  }\n\n}\n\nclass Block {\n  /**\n   * @param {number} timestamp\n   * @param {Transaction[]} transactions\n   * @param {string} previousHash\n   */\n  constructor(timestamp, transactions, previousHash = '') {\n    this.previousHash = previousHash;\n    this.timestamp = timestamp;\n    this.transactions = transactions;\n    this.nonce = 0;\n    this.hash = this.calculateHash();\n  }\n  /**\n   * Returns the SHA256 of this block (by processing all the data stored\n   * inside this block)\n   *\n   * @returns {string}\n   */\n\n\n  calculateHash() {\n    return SHA256(this.previousHash + this.timestamp + JSON.stringify(this.transactions) + this.nonce).toString();\n  }\n  /**\n   * Starts the mining process on the block. It changes the 'nonce' until the hash\n   * of the block starts with enough zeros (= difficulty)\n   *\n   * @param {number} difficulty\n   */\n\n\n  mineBlock(difficulty) {\n    while (this.hash.substring(0, difficulty) !== Array(difficulty + 1).join('0')) {\n      this.nonce++;\n      this.hash = this.calculateHash();\n    }\n\n    console.log(`Block mined: ${this.hash}`);\n  }\n  /**\n   * Validates all the transactions inside this block (signature + hash) and\n   * returns true if everything checks out. False if the block is invalid.\n   *\n   * @returns {boolean}\n   */\n\n\n  hasValidTransactions() {\n    for (const tx of this.transactions) {\n      if (!tx.isValid()) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nclass Blockchain {\n  constructor() {\n    this.chain = [this.createGenesisBlock()];\n    this.difficulty = 2;\n    this.pendingTransactions = [];\n    this.miningReward = 100;\n  }\n  /**\n   * @returns {Block}\n   */\n\n\n  createGenesisBlock() {\n    return new Block(Date.parse('2017-01-01'), [], '0');\n  }\n  /**\n   * Returns the latest block on our chain. Useful when you want to create a\n   * new Block and you need the hash of the previous Block.\n   *\n   * @returns {Block[]}\n   */\n\n\n  getLatestBlock() {\n    return this.chain[this.chain.length - 1];\n  }\n  /**\n   * Takes all the pending transactions, puts them in a Block and starts the\n   * mining process. It also adds a transaction to send the mining reward to\n   * the given address.\n   *\n   * @param {string} miningRewardAddress\n   */\n\n\n  minePendingTransactions(miningRewardAddress) {\n    const rewardTx = new Transaction(null, miningRewardAddress, this.miningReward);\n    this.pendingTransactions.push(rewardTx);\n    let block = new Block(Date.now(), this.pendingTransactions, this.getLatestBlock().hash);\n    block.mineBlock(this.difficulty);\n    console.log('Block successfully mined!');\n    this.chain.push(block);\n    this.pendingTransactions = [];\n  }\n  /**\n   * Add a new transaction to the list of pending transactions (to be added\n   * next time the mining process starts). This verifies that the given\n   * transaction is properly signed.\n   *\n   * @param {Transaction} transaction\n   */\n\n\n  addTransaction(transaction) {\n    if (!transaction.fromAddress || !transaction.toAddress) {\n      throw new Error('Transaction must include from and to address');\n    } // Verify the transactiion\n\n\n    if (!transaction.isValid()) {\n      throw new Error('Cannot add invalid transaction to chain');\n    }\n\n    if (transaction.amount <= 0) {\n      throw new Error('Transaction amount should be higher than 0');\n    }\n\n    this.pendingTransactions.push(transaction);\n  }\n  /**\n   * Returns the balance of a given wallet address.\n   *\n   * @param {string} address\n   * @returns {number} The balance of the wallet\n   */\n\n\n  getBalanceOfAddress(address) {\n    let balance = 0;\n\n    for (const block of this.chain) {\n      for (const trans of block.transactions) {\n        if (trans.fromAddress === address) {\n          balance -= trans.amount;\n        }\n\n        if (trans.toAddress === address) {\n          balance += trans.amount;\n        }\n      }\n    }\n\n    return balance;\n  }\n  /**\n   * Returns a list of all transactions that happened\n   * to and from the given wallet address.\n   *\n   * @param  {string} address\n   * @return {Transaction[]}\n   */\n\n\n  getAllTransactionsForWallet(address) {\n    const txs = [];\n\n    for (const block of this.chain) {\n      for (const tx of block.transactions) {\n        if (tx.fromAddress === address || tx.toAddress === address) {\n          txs.push(tx);\n        }\n      }\n    }\n\n    return txs;\n  }\n  /**\n   * Loops over all the blocks in the chain and verify if they are properly\n   * linked together and nobody has tampered with the hashes. By checking\n   * the blocks it also verifies the (signed) transactions inside of them.\n   *\n   * @returns {boolean}\n   */\n\n\n  isChainValid() {\n    // Check if the Genesis block hasn't been tampered with by comparing\n    // the output of createGenesisBlock with the first block on our chain\n    const realGenesis = JSON.stringify(this.createGenesisBlock());\n\n    if (realGenesis !== JSON.stringify(this.chain[0])) {\n      return false;\n    } // Check the remaining blocks on the chain to see if there hashes and\n    // signatures are correct\n\n\n    for (let i = 1; i < this.chain.length; i++) {\n      const currentBlock = this.chain[i];\n\n      if (!currentBlock.hasValidTransactions()) {\n        return false;\n      }\n\n      if (currentBlock.hash !== currentBlock.calculateHash()) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n}\n\nmodule.exports.Blockchain = Blockchain;\nmodule.exports.Block = Block;\nmodule.exports.Transaction = Transaction;","map":null,"metadata":{},"sourceType":"script"}